import pytest
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from tasties_app.models import Category


class TestCategoryModel:
    @pytest.mark.django_db
    def test_create_categories(self, categories):
        """
        Verifies fixtures 'categories' and 'recipes' properly
           saved their data as expected

        Args:
            categories (fixture): fixture 'categories'
            recipes (fixture): fixture 'recipes'
        """
        all_category = Category.objects.all()
        for category in categories:
            assert category in all_category

    @pytest.mark.django_db
    def test_get_recipes_by_category(self, categorized_recipes):
        """
        Verifies method 'get_recipes_by_category' provides intended functionality

        Args:
            categories (fixture): fixture 'categories'
            recipes (fixture): fixture 'recipes'
            categorized_recipes (fixture): fixture 'categorized_recipes'
        """
        # define test variables
        recipes = categorized_recipes[0]
        categories = categorized_recipes[1]

        # generate recipe_by_category QuerySets
        recipes_by_category_1 = Category.get_recipes_by_category(categories[0])
        recipes_by_category_2 = Category.get_recipes_by_category(categories[1])
        # assert expected results
        assert recipes[1] not in recipes_by_category_1
        assert recipes[0], recipes[1] in recipes_by_category_2

    @pytest.mark.django_db
    def test_category_name_uniqueness(self, categories):
        """
        Verifies that a new Category cannot be saved, if it has the same name as an existing Category

        Args:
            categories (fixture): test data generated by fixture 'categories'
        """
        category_4 = Category(category_name="1")
        with pytest.raises(IntegrityError):
            category_4.save()  # attempting to save a new category with the same name as an existing one

    @pytest.mark.django_db
    def test_category_name_length_limit(self):
        """
        Verifies that a name of invalid length cannot be given to a Category
        """
        category_too_long = Category(category_name="String longer than 16 characters")
        with pytest.raises(ValidationError):
            category_too_long.clean_fields()  # attempting to validate a category with a name that's too long
        category_too_short = Category("")
        with pytest.raises(ValidationError):
            category_too_short.clean_fields()  # attempting to validate a category with an empty string

    @pytest.mark.django_db
    def test_category_must_have_name(self):
        """
        Verifies that validators do not allow constructing a Category without non-empty 'category_name' field
        """
        with pytest.raises(ValidationError):
            category_no_argument = Category()
            category_no_argument.clean_fields()

    @pytest.mark.django_db
    def test_category_to_string(self, categories):
        """
        Verifies that __str__ method acts as expected

        Args:
            categories (fixture): fixture 'categories'
        """
        assert str(categories[0]) == "1"
